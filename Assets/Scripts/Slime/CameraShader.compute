// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Texture3D<float> ColorMap;
Texture3D<float> TrailMap;

float4x4 cameraToWorld;
float4x4 cameraInverseProjection;
float opacity;
float4 color;

int width;
int height;
int depth;

RWTexture2D<float4> Result;

struct Ray
{
    float3 origin;
    float3 direction;
};

bool IntersectBox(float3 ro, float3 rd, out float tmin, out float tmax)
{
    float3 invDir = 1.0f / rd;

    float3 t0 = (-0.5f - ro) * invDir;
    float3 t1 = (0.5f - ro) * invDir;

    float3 tmin3 = min(t0, t1);
    float3 tmax3 = max(t0, t1);

    tmin = max(max(tmin3.x, tmin3.y), tmin3.z);
    tmax  = min(min(tmax3.x, tmax3.y), tmax3.z);

    return tmax >= max(tmin, 0.0f);
}

// float3 Trace(Ray ray)
// {
//     float tin, tout;
//     if (!IntersectBox(ray.origin, ray.direction, tin, tout))
//     {
//         return float3(0,0,0); // Background color
//     }

//     float t = max(tin, 0.0) + 1e-8;
//     float3 pos = ray.origin + ray.direction * t;

//     uint3 volumeDim;
//     TrailMap.GetDimensions(volumeDim.x, volumeDim.y, volumeDim.z);
    
//     float3 uvw = pos + 0.5;
//     float3 voxelPos = uvw * volumeDim;
//     int3 voxel = int3(floor(voxelPos));

//     int3 step = sign(ray.direction);
//     float3 tDelta = abs(1.0 / (ray.direction * volumeDim));

//     float3 distToNextBoundary;
//     distToNextBoundary.x = (step.x > 0) ? floor(voxelPos.x + 1.0) - voxelPos.x : voxelPos.x - floor(voxelPos.x);    
//     distToNextBoundary.y = (step.y > 0) ? floor(voxelPos.y + 1.0) - voxelPos.y : voxelPos.y - floor(voxelPos.y);
//     distToNextBoundary.z = (step.z > 0) ? floor(voxelPos.z + 1.0) - voxelPos.z : voxelPos.z - floor(voxelPos.z);

//     float3 tMax = t + (distToNextBoundary * tDelta);
//     float accum = 0.0;

//     [loop]
//     while (t < tout)
//     {
//         if (all(voxel >= 0) && all(voxel < int3(volumeDim)))
//         {
//             float alpha = TrailMap[voxel];
//             alpha = alpha * opacity;

//             accum += alpha * (1.0 - accum);
//             // if (alpha > 0.0) {
//             //     accum = 1.0;
//             //     break;
//             // }

//             if (accum >= 0.99) break; // Early exit if opaque
//         }
//         if (tMax.x < tMax.y)
//         {
//             if (tMax.x < tMax.z)
//             {
//                 voxel.x += step.x;
//                 t = tMax.x;
//                 tMax.x += tDelta.x;
//             }
//             else
//             {
//                 voxel.z += step.z;
//                 t = tMax.z;
//                 tMax.z += tDelta.z;
//             }
//         }
//         else
//         {
//             if (tMax.y < tMax.z)
//             {
//                 voxel.y += step.y;
//                 t = tMax.y;
//                 tMax.y += tDelta.y;
//             }
//             else
//             {
//                 voxel.z += step.z;
//                 t = tMax.z;
//                 tMax.z += tDelta.z;
//             }
//         }
//     }

//     float4 dst = float4(color.rgb * accum, 1.0);
//     return dst.rgb;
// }

float3 Trace(Ray ray)
{
    float tin, tout;
    if (!IntersectBox(ray.origin, ray.direction, tin, tout))
        return float3(0,0,0);

    tin = max(0.0f, tin);
    if (tin >= tout) return float3(0.0f,0.0f,0.0f);

    float3 dims = float3(width, height, depth);
    // float stepSize = 0.5 / width;
    float stepSize = 0.01f;

    float3 startPos = ray.origin + ray.direction * (tin + 1e-4);
    float3 posVoxel = (startPos + 0.5f) * dims;
    float3 stepVecVoxel = (ray.direction * stepSize) * dims;
    int maxSteps = int((tout - tin) / stepSize);
    
    float trans = 1.0f;

    [loop]
    for(int i = 0; i < maxSteps; i++)
    {
        float alpha = TrailMap[int3(posVoxel)] * opacity;
        trans *= (1.0f - alpha);
        if (trans < 0.02f) break;
        posVoxel += stepVecVoxel;
    }
    return color.rgb * (1.0f - trans);
}

Ray CreateCameraRay(float2 uv)
{
    float3 origin = mul(cameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    float3 direction = mul(cameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
    direction = mul(cameraToWorld, float4(direction, 0.0f)).xyz;
    direction = normalize(direction);
    
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint w, h;
    Result.GetDimensions(w, h);

    float2 uv = (id.xy + 0.5f);
    uv.x /= w;
    uv.y /= h;
    uv = uv * 2.0f - 1.0f;

    Ray ray = CreateCameraRay(uv);
    float3 result = Trace(ray);
    Result[id.xy] = float4(result, 1.0f);
}
