#pragma kernel Update

struct Agent {
	float3 position;
	float padding0;
	
	float3 direction;
	float padding1;
	// float3 up;

	int3 speciesMask;
	int speciesIndex;
};

struct SpeciesSettings {
	float moveSpeed;
	float turnSpeed;

	float sensorAngleDegrees;
	float sensorOffsetDst;
	int sensorSize;

	float padding0;
    float padding1;
    float padding2;

	float4 colour;
};

StructuredBuffer<SpeciesSettings> speciesSettings;
uint numSpecies;

RWStructuredBuffer<Agent> agents;
uint numAgents;

RWTexture3D<float4> TrailMap;

int width;
int height;
int depth;

float trailWeight;

float deltaTime;
float time;

// Hash function www.cs.ubc.ca/~rbridson/docs/schechter-sca08-turbulence.pdf
uint hash(uint state)
{
    state ^= 2747636419u;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    return state;
}

float scaleToRange01(uint state)
{
    return state / 4294967295.0;
}


float sense(Agent agent, SpeciesSettings settings, float3 sensorDir) {
	float3 sensorPos = agent.position + sensorDir * settings.sensorOffsetDst;
	int sensorCentreX = (int) sensorPos.x;
	int sensorCentreY = (int) sensorPos.y;
	int sensorCentreZ = (int) sensorPos.z;

	float sum = 0;

	int4 senseWeight = int4(agent.speciesMask,0) * 2 - 1;

	for (int offsetX = -settings.sensorSize; offsetX <= settings.sensorSize; offsetX ++) {
		for (int offsetY = -settings.sensorSize; offsetY <= settings.sensorSize; offsetY ++) {
			for (int offsetZ = -settings.sensorSize; offsetZ <= settings.sensorSize; offsetZ ++) {
				int sampleX = min(width - 1, max(0, sensorCentreX + offsetX));
				int sampleY = min(height - 1, max(0, sensorCentreY + offsetY));
				int sampleZ = min(depth - 1, max(0, sensorCentreZ + offsetZ));
				sum += dot(senseWeight, TrailMap[int3(sampleX,sampleY,sampleZ)]);
			}
		}
	}

	return sum;
}

[numthreads(256,1,1)]
void Update (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numAgents) {
		return;
	}

	Agent agent = agents[id.x];
	SpeciesSettings settings = speciesSettings[agent.speciesIndex];
	float3 pos = agent.position;

	uint random = hash(pos.x + pos.y * width + pos.z * width * height + hash(id.x + time * 100000));

	// Steer based on sensory data
	float sensorAngleRad = settings.sensorAngleDegrees * (3.1415 / 180);
	float horizontal = cos(sensorAngleRad);
	float radial = sin(sensorAngleRad);

	float3 helper = abs(agent.direction.y) < 0.999 ? float3(0, 1, 0) : float3(1, 0, 0);
	float3 agentRight = normalize(cross(agent.direction, helper));
	float3 agentUp    = cross(agentRight, agent.direction);

	float weightForward = sense(agent, settings, agent.direction);
	float weightLeft = sense(agent, settings, agent.direction * horizontal + agentRight * -radial);
	float weightRight = sense(agent, settings, agent.direction * horizontal + agentRight * radial);
	float weightDown = sense(agent, settings, agent.direction * horizontal + agentUp * -radial);
	float weightUp = sense(agent, settings, agent.direction * horizontal + agentUp * radial);

	float maxWeightRadial = max(max(weightLeft, weightRight), max(weightUp, weightDown));
	float minWeightRadial = min(min(weightLeft, weightRight), min(weightUp, weightDown));
	
	float randomSteerStrength = scaleToRange01(random);
	float turnSpeed = settings.turnSpeed / 180;

	// Continue in same direction
	if (weightForward > maxWeightRadial) {
		agent.direction += 0;
	}
	else if (weightForward < minWeightRadial || maxWeightRadial == minWeightRadial) {
		float3 randomDir = (randomSteerStrength - 0.5) *  agentRight + (scaleToRange01(hash(random+1)) - 0.5) * agentUp;
    	agent.direction += randomDir * turnSpeed;
	}
	// Turn right
	else if (weightRight==maxWeightRadial) {
		agent.direction += agentRight * turnSpeed * randomSteerStrength;
	}
	// Turn left
	else if (weightLeft == maxWeightRadial) {
		agent.direction -= agentRight * turnSpeed * randomSteerStrength;
	}
	// Turn up
	else if (weightUp == maxWeightRadial) {
		agent.direction += agentUp * turnSpeed * randomSteerStrength;
	}
	// Turn down
	else if (weightDown == maxWeightRadial) {
		agent.direction -= agentUp * turnSpeed * randomSteerStrength;
	}
	agent.direction = normalize(agent.direction);

	// Update position
	float3 newPos = agent.position + agent.direction * deltaTime * settings.moveSpeed;

	// Clamp position to map boundaries, and pick new random move dir if hit boundary
	if (newPos.x < 0 || newPos.x >= width || newPos.y < 0 || newPos.y >= height || newPos.z < 0 || newPos.z >= depth) {
		random = hash(random);
		uint random1 = hash(random);
		uint random2 = hash(random1);
		newPos.x = min(width-1,max(0, newPos.x));
		newPos.y = min(height-1,max(0, newPos.y));
		newPos.z = min(depth-1,max(0, newPos.z));
		agent.direction =  normalize(float3(scaleToRange01(random) - 0.5, scaleToRange01(random1) - 0.5, scaleToRange01(random2) - 0.5));
	}
	else {
		int3 coord = int3(newPos);
		float4 oldTrail = TrailMap[coord];
		TrailMap[coord] = min(1, oldTrail + int4(agent.speciesMask,0) * trailWeight * deltaTime);
	}
	
	agents[id.x].position = newPos;
	agents[id.x].direction = agent.direction;
}

#pragma kernel Diffuse

float decayRate;
float diffuseRate;
RWTexture3D<float4> DiffusedTrailMap;

[numthreads(8,8,8)]
void Diffuse (uint3 id : SV_DispatchThreadID)
{
	if (id.x < 0 || id.x >= (uint)width || id.y < 0 || id.y >= (uint)height || id.z < 0 || id.z >= (uint)depth) {
		return;
	}

	float4 sum = 0;
	float4 originalCol = TrailMap[id.xyz];
	// 3x3 blur
	for (int offsetX = -1; offsetX <= 1; offsetX ++) {
		for (int offsetY = -1; offsetY <= 1; offsetY ++) {
			for (int offsetZ = -1; offsetZ <= 1; offsetZ ++) {
				int sampleX = min(width-1, max(0, id.x + offsetX));
				int sampleY = min(height-1, max(0, id.y + offsetY));
				int sampleZ = min(depth-1, max(0, id.z + offsetZ));
				sum += TrailMap[int3(sampleX,sampleY,sampleZ)];
			}
		}
	}

	float4 blurredCol = sum / 27;
	float diffuseWeight = saturate(diffuseRate * deltaTime);
	blurredCol = originalCol * (1 - diffuseWeight) + blurredCol * (diffuseWeight);

	//DiffusedTrailMap[id.xy] = blurredCol * saturate(1 - decayRate * deltaTime);
	DiffusedTrailMap[id.xyz] = max(0, blurredCol - decayRate * deltaTime);
}

#pragma kernel UpdateColorMap
RWTexture3D<float4> ColorMap;
[numthreads(8,8,8)]
void UpdateColorMap (uint3 id : SV_DispatchThreadID)
{
	if (id.x < 0 || id.x >= (uint)width || id.y < 0 || id.y >= (uint)height || id.z < 0 || id.z >= (uint)depth) {
		return;
	}

	float4 map = TrailMap[id.xyz];

	float4 colour = 0;
	for (uint i = 0; i < numSpecies; i ++) {
		float4 mask = float4(i==0, i==1, i==2,i==3);
		colour += speciesSettings[i].colour * dot(map, mask); 
	}
	ColorMap[id.xyz] = colour;
}