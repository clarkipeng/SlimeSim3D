#pragma kernel Update

//consts
float3 invSize;
float deltaTime;
float time;

half moveSpeed;
half turnSpeed;
half sensorOffsetDst;
half cosAngle;
half sinAngle;

uint numAgents;

int resolution;
int boundaryRadius;

half trailWeight;

Texture3D<half> ReadTrailMap; 
SamplerState samplerReadTrailMap;
RWTexture3D<float> WriteTrailMap;

struct Agent {
	float3 position;
	float pad0;
	float3 direction;
	uint rngState;
};
RWStructuredBuffer<Agent> agents;

// LCG Random
float NextFloat(inout uint state)
{
	state += time * 100000;
    state ^= 2747636419u;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    return state / 4294967295.0;
}

half sense(Agent agent, float3 sensorDir) {
    float3 sensorPos = agent.position + sensorDir * sensorOffsetDst;
	if (any(sensorPos < 0) || any(sensorPos >= resolution)) {
        return 0;
    }
    float3 uv = (sensorPos + 0.5) * invSize;
    return ReadTrailMap.SampleLevel(samplerReadTrailMap, uv, 0);
}

[numthreads(256,1,1)]
void Update (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numAgents) {
		return;
	}

	Agent agent = agents[id.x];
	float3 pos = agent.position;

	float3 helper = abs(agent.direction.y) < 0.999 ? float3(0, 1, 0) : float3(1, 0, 0);
	float3 agentRight = normalize(cross(agent.direction, helper));
	float3 agentUp    = cross(agentRight, agent.direction);

	half weightForward = sense(agent, agent.direction);
	half weightLeft    = sense(agent, agent.direction * cosAngle + agentRight * -sinAngle);
	half weightRight   = sense(agent, agent.direction * cosAngle + agentRight * sinAngle);
	half weightDown    = sense(agent, agent.direction * cosAngle + agentUp * -sinAngle);
	half weightUp      = sense(agent, agent.direction * cosAngle + agentUp * sinAngle);

	half maxWeightRadial = max(max(weightLeft, weightRight), max(weightUp, weightDown));
	half minWeightRadial = min(min(weightLeft, weightRight), min(weightUp, weightDown));
	
	float rand = NextFloat(agent.rngState);

	// Continue in same direction
	if (weightForward > maxWeightRadial) {
	}
	else if (weightForward < minWeightRadial || maxWeightRadial == minWeightRadial) {
		float3 randomDir = (rand - 0.5) *  agentRight + (NextFloat(agent.rngState) - 0.5) * agentUp;
    	agent.direction += randomDir * turnSpeed;
	}
	else if (weightRight == maxWeightRadial) agent.direction += agentRight * turnSpeed * rand;
	else if (weightLeft  == maxWeightRadial) agent.direction -= agentRight * turnSpeed * rand;
	else if (weightUp    == maxWeightRadial) agent.direction += agentUp * turnSpeed * rand;
	else if (weightDown  == maxWeightRadial) agent.direction -= agentUp * turnSpeed * rand;

	agent.direction = normalize(agent.direction);
	float3 newPos = agent.position + agent.direction * deltaTime * moveSpeed;

	float3 center = float3(resolution, resolution, resolution) * 0.5;
    float3 offset = newPos - center;
    float distSq = dot(offset, offset);
    bool outsideSphere = distSq > boundaryRadius * boundaryRadius;
    if (outsideSphere)
    {
        newPos = center + offset * rsqrt(distSq) * (boundaryRadius - 0.01f);
		newPos += lerp(0.5f, -0.5f, step(center, newPos)); // round towards center
    }
    bool outsideBox = any(newPos < 0) || any(newPos >= resolution);
    if (outsideBox) 
    {
        newPos = clamp(newPos, 0.0, resolution - 1);
    }
    if (outsideSphere || outsideBox)
    {
		// uint r = agent.rngState; 
        // r ^= r << 13; r ^= r >> 17; r ^= r << 5; 
        // agent.rngState = r;

        // float3 randDir;
        // randDir.x = ((r & 0x3FF) / 1023.0f) - 0.5f;
        // randDir.y = (((r >> 10) & 0x3FF) / 1023.0f) - 0.5f;
        // randDir.z = (((r >> 20) & 0x3FF) / 1023.0f) - 0.5f;

        float3 randDir = float3(NextFloat(agent.rngState), NextFloat(agent.rngState), NextFloat(agent.rngState)) - 0.5f;
		// float3 randDir = float3(x, y, z);
		if (outsideSphere && dot(offset, randDir) > 0.0f)
		{
			randDir = -randDir;
		}
        agent.direction = normalize(randDir);
    }

	WriteTrailMap[int3(newPos)] += trailWeight;
	
	agent.position = newPos;
	agents[id.x] = agent;
}

#pragma kernel Diffuse

half diffuseFactor;
half decayFactor;

Texture3D<half> TrailMap;
SamplerState samplerTrailMap;
RWTexture3D<float4> DiffusedTrailMap;

[numthreads(8,8,4)]
void Diffuse (uint3 id : SV_DispatchThreadID)
{
	if (any(id >= uint3(resolution, resolution, resolution))) return;

	// float3 uv = (id + 0.5f) * invSize;

	// half sum = TrailMap.SampleLevel(samplerTrailMap, uv, 0);

    // sum += TrailMap.SampleLevel(samplerTrailMap, uv, 0, int3(-1, 0, 0));
    // sum += TrailMap.SampleLevel(samplerTrailMap, uv, 0, int3( 1, 0, 0));
    // sum += TrailMap.SampleLevel(samplerTrailMap, uv, 0, int3( 0,-1, 0));
    // sum += TrailMap.SampleLevel(samplerTrailMap, uv, 0, int3( 0, 1, 0));
    // sum += TrailMap.SampleLevel(samplerTrailMap, uv, 0, int3( 0, 0,-1));
    // sum += TrailMap.SampleLevel(samplerTrailMap, uv, 0, int3( 0, 0, 1));

	int3 pos = int3(id);
	half sum = TrailMap.Load(int4(pos, 0));

	sum += TrailMap.Load(int4(max(0, pos + int3(-1, 0, 0)), 0));
    sum += TrailMap.Load(int4(min(resolution-1, pos + int3( 1, 0, 0)), 0));
    
    sum += TrailMap.Load(int4(max(0, pos + int3( 0,-1, 0)), 0));
    sum += TrailMap.Load(int4(min(resolution-1, pos + int3( 0, 1, 0)), 0));
    
    sum += TrailMap.Load(int4(max(0, pos + int3( 0, 0,-1)), 0));
    sum += TrailMap.Load(int4(min(resolution-1, pos + int3( 0, 0, 1)), 0));
	

	half original = TrailMap[id];

    half blurred = sum * 0.142857h;
    half result = lerp(original, blurred, diffuseFactor);
	
    DiffusedTrailMap[id] = max(0.0h, result - decayFactor);
}