#pragma kernel Update

//consts
float3 invSize;
float deltaTime;
float time;

half moveSpeed;
half turnSpeed;
half sensorOffsetDst;
half cosAngle;
half sinAngle;

uint numAgents;
int width, height, depth;

half trailWeight;

Texture3D<half> ReadTrailMap; 
SamplerState samplerReadTrailMap;
RWTexture3D<float> WriteTrailMap;

struct Agent {
	float3 position;
	float pad0;
	float3 direction;
	uint rngState;
};
RWStructuredBuffer<Agent> agents;

// LCG Random
// float NextFloat(inout uint state) {
//     state = state * 747796405 + 2891336453;
//     float result = ((state >> ((state >> 28) + 4)) ^ state) * 2.77555756e-17;
//     return result;
// }
float NextFloat(inout uint state) 
{
    state = state * 1664525u + 1013904223u;
    return float(state) * (1.0 / 4294967296.0);
}

half sense(Agent agent, float3 sensorDir) {
    float3 sensorPos = agent.position + sensorDir * sensorOffsetDst;
    float3 uv = (sensorPos + 0.5) * invSize;
    return ReadTrailMap.SampleLevel(samplerReadTrailMap, uv, 0);
}

[numthreads(256,1,1)]
void Update (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numAgents) {
		return;
	}

	Agent agent = agents[id.x];
	float3 pos = agent.position;

	float3 helper = abs(agent.direction.y) < 0.999 ? float3(0, 1, 0) : float3(1, 0, 0);
	float3 agentRight = normalize(cross(agent.direction, helper));
	float3 agentUp    = cross(agentRight, agent.direction);

	half weightForward = sense(agent, agent.direction);
	half weightLeft    = sense(agent, agent.direction * cosAngle + agentRight * -sinAngle);
	half weightRight   = sense(agent, agent.direction * cosAngle + agentRight * sinAngle);
	half weightDown    = sense(agent, agent.direction * cosAngle + agentUp * -sinAngle);
	half weightUp      = sense(agent, agent.direction * cosAngle + agentUp * sinAngle);

	half maxWeightRadial = max(max(weightLeft, weightRight), max(weightUp, weightDown));
	half minWeightRadial = min(min(weightLeft, weightRight), min(weightUp, weightDown));
	
	float rand = NextFloat(agent.rngState);

	// Continue in same direction
	if (weightForward > maxWeightRadial) {
	}
	else if (weightForward < minWeightRadial || maxWeightRadial == minWeightRadial) {
		float3 randomDir = (rand - 0.5) *  agentRight + (NextFloat(agent.rngState) - 0.5) * agentUp;
    	agent.direction += randomDir * turnSpeed;
	}
	else if (weightRight==maxWeightRadial ) agent.direction += agentRight * turnSpeed * rand;
	else if (weightLeft == maxWeightRadial) agent.direction -= agentRight * turnSpeed * rand;
	else if (weightUp == maxWeightRadial  )	agent.direction += agentUp * turnSpeed * rand;
	else if (weightDown == maxWeightRadial) agent.direction -= agentUp * turnSpeed * rand;

	agent.direction = normalize(agent.direction);
	float3 newPos = agent.position + agent.direction * deltaTime * moveSpeed;

	// Clamp position to map boundaries, and pick new random move dir if hit boundary
	if (newPos.x < 0 || newPos.x >= width || newPos.y < 0 || newPos.y >= height || newPos.z < 0 || newPos.z >= depth) {
		newPos = min(float3(width, height, depth), max(0.0f, newPos));
		float r1 = NextFloat(agent.rngState); 
        float r2 = NextFloat(agent.rngState);
        float r3 = NextFloat(agent.rngState);
		agent.direction = normalize(float3(r1 - 0.5, r2 - 0.5, r3 - 0.5));
	}
	WriteTrailMap[int3(newPos)] += trailWeight;
	
	agent.position = newPos;
	agents[id.x] = agent;
}

#pragma kernel Diffuse

half diffuseFactor;
half decayFactor;

Texture3D<half> TrailMap;
SamplerState samplerTrailMap;
RWTexture3D<float> DiffusedTrailMap;

[numthreads(8,8,4)]
void Diffuse (uint3 id : SV_DispatchThreadID)
{
	if (any(id >= uint3(width, height, depth))) return;

	float3 uv = (id + 0.5f) * invSize;

	half sum = TrailMap.SampleLevel(samplerTrailMap, uv, 0);

    sum += TrailMap.SampleLevel(samplerTrailMap, uv, 0, int3(-1, 0, 0));
    sum += TrailMap.SampleLevel(samplerTrailMap, uv, 0, int3( 1, 0, 0));
    sum += TrailMap.SampleLevel(samplerTrailMap, uv, 0, int3( 0,-1, 0));
    sum += TrailMap.SampleLevel(samplerTrailMap, uv, 0, int3( 0, 1, 0));
    sum += TrailMap.SampleLevel(samplerTrailMap, uv, 0, int3( 0, 0,-1));
    sum += TrailMap.SampleLevel(samplerTrailMap, uv, 0, int3( 0, 0, 1));

	half original = TrailMap[id];

    half blurred = sum * 0.142857h;
    half result = lerp(original, blurred, diffuseFactor);
	
    DiffusedTrailMap[id] = max(0.0h, result - decayFactor);
}