#pragma kernel Default

Texture3D<float> TrailMap;
SamplerState samplerTrailMap;

float4x4 cameraToWorld;
float4x4 cameraInverseProjection;

half alphaScale;
half alphaAmb;

int resolution;
int boundaryRadius;

RWTexture2D<float4> Result;

struct Ray
{
    float3 origin;
    float3 direction;
};

bool IntersectBounds(float3 ro, float3 rd, out float tmin, out float tmax)
{
    float3 invDir = 1.0f / rd;
    float3 t0 = (-0.5f - ro) * invDir;
    float3 t1 = ( 0.5f - ro) * invDir;

    float3 tmin3 = min(t0, t1);
    float3 tmax3 = max(t0, t1);

    float boxTmin = max(max(tmin3.x, tmin3.y), tmin3.z);
    float boxTmax = min(min(tmax3.x, tmax3.y), tmax3.z);

    if (boxTmax < max(boxTmin, 0.0f)) return false;

    float radius = ((float)boundaryRadius)/resolution;
    
    float b = dot(ro, rd);
    float c = dot(ro, ro) - (radius * radius);
    float h = b*b - c;

    if (h < 0.0f) return false;

    float sqrtH = sqrt(h);
    float sphereTmin = -b - sqrtH;
    float sphereTmax = -b + sqrtH;

    tmin = max(boxTmin, sphereTmin);
    tmax = min(boxTmax, sphereTmax);

    return tmax >= max(tmin, 0.0f);
}


float randJitter(float2 co) {
    return frac(sin(dot(co.xy, float2(12.9898, 78.233))) * 43758.5453);
}

Ray CreateCameraRay(float2 uv)
{
    float3 origin = mul(cameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    float3 direction = mul(cameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
    direction = mul(cameraToWorld, float4(direction, 0.0f)).xyz;
    direction = normalize(direction);
    
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}


float4 color;

float3 GetDefaultColor()
{
    return color;
}

float3 TraceDefault(Ray ray, float2 uv)
{
    float tin, tout;
    if (!IntersectBounds(ray.origin, ray.direction, tin, tout))
        return float3(0,0,0);

    tin = max(0.0f, tin);
    if (tin >= tout) return float3(0.0f,0.0f,0.0f);

    float3 dims = float3(resolution, resolution, resolution);
    float stepSize = 1.0 / resolution;

    tin += randJitter(uv) * stepSize;

    float3 startPos = ray.origin + ray.direction * tin;
    float3 pos = (startPos + 0.5f);
    float3 stepVec = (ray.direction * stepSize);
    int maxSteps = int((tout - tin) / stepSize);
    
    float3 accColor = 0.0;
    float transmittance = 1.0;

    [loop]
    for(int i = 0; i < maxSteps; i++)
    {
        if (any(pos < 0) || any(pos > 1)) break;
        float density = TrailMap.SampleLevel(samplerTrailMap, pos, 0);
        density = pow(density, alphaScale);

        if (density > 0.000001) 
        {
            float3 col = GetDefaultColor();
            accColor += col * density * transmittance;
            transmittance *= (1.0 - density);
            if (transmittance < 0.01) break;
        }
        else
        {
            transmittance *= (1 - alphaAmb);
        }

        pos += stepVec;
    }
    return accColor;
}

[numthreads(8,8,1)]
void Default (uint3 id : SV_DispatchThreadID)
{
    uint w, h;
    Result.GetDimensions(w, h);

    float2 uv = (id.xy + 0.5f);
    uv.x /= w;
    uv.y /= h;
    uv = uv * 2.0f - 1.0f;

    Ray ray = CreateCameraRay(uv);
    float3 result = TraceDefault(ray, uv);
    Result[id.xy] = float4(result, 1.0f);
}

#pragma kernel Gradient

float4 frontColor, backColor;

float3 GetGradientColor(float t)
{
    return lerp(frontColor, backColor, min(1,max(0,t)));
}

float3 TraceGradient(Ray ray, float2 uv)
{
    float tin, tout;
    if (!IntersectBounds(ray.origin, ray.direction, tin, tout))
        return float3(0,0,0);

    tin = max(0.0f, tin);
    if (tin >= tout) return float3(0.0f,0.0f,0.0f);

    float3 dims = float3(resolution, resolution, resolution);
    float stepSize = 1.0 / resolution;

    tin += randJitter(uv) * stepSize;

    float3 startPos = ray.origin + ray.direction * tin;
    float3 pos = (startPos + 0.5f);
    float3 stepVec = (ray.direction * stepSize);
    int maxSteps = int((tout - tin) / stepSize);
    
    float3 accColor = 0.0;
    float transmittance = 1.0;

    [loop]
    for(int i = 0; i < maxSteps; i++)
    {
        if (any(pos < 0) || any(pos > 1)) break;
        float density = TrailMap.SampleLevel(samplerTrailMap, pos, 0);
        density = pow(density, alphaScale);

        if (density > 0.00001) 
        {
            float radiusSq = dot(pos - 0.5, pos - 0.5) * 4;
            float3 col = GetGradientColor(radiusSq);
            accColor += col * density * transmittance;
            transmittance *= (1.0 - density);
            if (transmittance < 0.01) break;
        }
        else
        {
            transmittance *= (1 - alphaAmb);
        }

        pos += stepVec;
    }
    return accColor;
}

[numthreads(8,8,1)]
void Gradient (uint3 id : SV_DispatchThreadID)
{
    uint w, h;
    Result.GetDimensions(w, h);

    float2 uv = (id.xy + 0.5f);
    uv.x /= w;
    uv.y /= h;
    uv = uv * 2.0f - 1.0f;

    Ray ray = CreateCameraRay(uv);
    float3 result = TraceGradient(ray, uv);
    Result[id.xy] = float4(result, 1.0f);
}

#pragma kernel Density

float4 colorLow,colorMid,colorHigh;
half midThresh;

float3 GetDensityColor(float t)
{
    if (t < midThresh) return lerp(colorLow, colorMid, t / midThresh);
    return lerp(colorMid, colorHigh, (t - midThresh) / (1 - midThresh));
}

float3 TraceDensity(Ray ray, float2 uv)
{
    float tin, tout;
    if (!IntersectBounds(ray.origin, ray.direction, tin, tout))
        return float3(0,0,0);

    tin = max(0.0f, tin);
    if (tin >= tout) return float3(0.0f,0.0f,0.0f);

    float3 dims = float3(resolution, resolution, resolution);
    float stepSize = 1.0 / resolution;

    tin += randJitter(uv) * stepSize;

    float3 startPos = ray.origin + ray.direction * tin;
    float3 pos = (startPos + 0.5f);
    float3 stepVec = (ray.direction * stepSize);
    int maxSteps = int((tout - tin) / stepSize);
    
    float3 accColor = 0.0;
    float transmittance = 1.0;

    [loop]
    for(int i = 0; i < maxSteps; i++)
    {
        if (any(pos < 0) || any(pos > 1)) break;
        float density = TrailMap.SampleLevel(samplerTrailMap, pos, 0);
        density = pow(density, alphaScale);


        if (density > 0.00001) 
        {
            density = (1-alphaAmb) * density + alphaAmb;
            float radiusSq = dot(pos - 0.5, pos - 0.5) * 4;
            float3 col = GetDensityColor(density);
            accColor += col * density * transmittance;
            transmittance *= (1.0 - density);
            if (transmittance < 0.01) break;
        }
        else
        {
            transmittance *= (1 - alphaAmb);
        }

        pos += stepVec;
    }
    return accColor;
}

[numthreads(8,8,1)]
void Density (uint3 id : SV_DispatchThreadID)
{
    uint w, h;
    Result.GetDimensions(w, h);

    float2 uv = (id.xy + 0.5f);
    uv.x /= w;
    uv.y /= h;
    uv = uv * 2.0f - 1.0f;

    Ray ray = CreateCameraRay(uv);
    float3 result = TraceDensity(ray, uv);
    Result[id.xy] = float4(result, 1.0f);
}
